// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "task/v1beta/message.proto" (package "task.v1beta", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MESSAGE_TYPE } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message task.v1beta.Task
 */
export interface Task {
	/**
	 * @generated from protobuf field: string name = 1;
	 */
	name: string;
	/**
	 * @generated from protobuf field: repeated task.v1beta.Field fields = 2;
	 */
	fields: Field[];
	/**
	 * @generated from protobuf field: string due_date = 3;
	 */
	dueDate: string;
	/**
	 * @generated from protobuf field: bool done = 4;
	 */
	done: boolean;
	/**
	 * @generated from protobuf field: string id = 5;
	 */
	id: string;
}
/**
 * @generated from protobuf message task.v1beta.Field
 */
export interface Field {
	/**
	 * @generated from protobuf field: string name = 1;
	 */
	name: string;
	/**
	 * @generated from protobuf field: string value = 2;
	 */
	value: string;
	/**
	 * @generated from protobuf field: task.v1beta.FieldType type = 3;
	 */
	type: FieldType;
}
/**
 * @generated from protobuf enum task.v1beta.FieldType
 */
export enum FieldType {
	/**
	 * @generated from protobuf enum value: FIELD_TYPE_STRING = 0;
	 */
	STRING = 0
}
/**
 * @generated from protobuf enum task.v1beta.EventType
 */
export enum EventType {
	/**
	 * @generated from protobuf enum value: EVENT_TYPE_CLICK = 0;
	 */
	CLICK = 0,
	/**
	 * @generated from protobuf enum value: EVENT_TYPE_CREATE = 1;
	 */
	CREATE = 1,
	/**
	 * @generated from protobuf enum value: EVENT_TYPE_UPDATE = 2;
	 */
	UPDATE = 2,
	/**
	 * @generated from protobuf enum value: EVENT_TYPE_DELETE = 3;
	 */
	DELETE = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
	constructor() {
		super('task.v1beta.Task', [
			{ no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'fields', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
			{ no: 3, name: 'due_date', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'done', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 5, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<Task>): Task {
		const message = { name: '', fields: [], dueDate: '', done: false, id: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<Task>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: Task
	): Task {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string name */ 1:
					message.name = reader.string();
					break;
				case /* repeated task.v1beta.Field fields */ 2:
					message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
					break;
				case /* string due_date */ 3:
					message.dueDate = reader.string();
					break;
				case /* bool done */ 4:
					message.done = reader.bool();
					break;
				case /* string id */ 5:
					message.id = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: Task,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string name = 1; */
		if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* repeated task.v1beta.Field fields = 2; */
		for (let i = 0; i < message.fields.length; i++)
			Field.internalBinaryWrite(
				message.fields[i],
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join();
		/* string due_date = 3; */
		if (message.dueDate !== '') writer.tag(3, WireType.LengthDelimited).string(message.dueDate);
		/* bool done = 4; */
		if (message.done !== false) writer.tag(4, WireType.Varint).bool(message.done);
		/* string id = 5; */
		if (message.id !== '') writer.tag(5, WireType.LengthDelimited).string(message.id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message task.v1beta.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Field$Type extends MessageType<Field> {
	constructor() {
		super('task.v1beta.Field', [
			{ no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{
				no: 3,
				name: 'type',
				kind: 'enum',
				T: () => ['task.v1beta.FieldType', FieldType, 'FIELD_TYPE_']
			}
		]);
	}
	create(value?: PartialMessage<Field>): Field {
		const message = { name: '', value: '', type: 0 };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<Field>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: Field
	): Field {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string name */ 1:
					message.name = reader.string();
					break;
				case /* string value */ 2:
					message.value = reader.string();
					break;
				case /* task.v1beta.FieldType type */ 3:
					message.type = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: Field,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string name = 1; */
		if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name);
		/* string value = 2; */
		if (message.value !== '') writer.tag(2, WireType.LengthDelimited).string(message.value);
		/* task.v1beta.FieldType type = 3; */
		if (message.type !== 0) writer.tag(3, WireType.Varint).int32(message.type);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message task.v1beta.Field
 */
export const Field = new Field$Type();
