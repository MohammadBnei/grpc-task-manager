// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "user/v1alpha/message.proto" (package "user.v1alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MESSAGE_TYPE } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
import { Timestamp } from '../../google/protobuf/timestamp';
/**
 * @generated from protobuf message user.v1alpha.User
 */
export interface User {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string;
	/**
	 * @generated from protobuf field: string first_name = 2;
	 */
	firstName: string;
	/**
	 * @generated from protobuf field: string last_name = 3;
	 */
	lastName: string;
	/**
	 * @generated from protobuf field: string email = 4;
	 */
	email: string;
	/**
	 * @generated from protobuf field: google.protobuf.Timestamp created_at = 5;
	 */
	createdAt?: Timestamp;
	/**
	 * @generated from protobuf field: google.protobuf.Timestamp updated_at = 6;
	 */
	updatedAt?: Timestamp;
	/**
	 * @generated from protobuf field: user.v1alpha.UserRole role = 7;
	 */
	role: UserRole;
}
/**
 * @generated from protobuf message user.v1alpha.RegisterRequest
 */
export interface RegisterRequest {
	/**
	 * @generated from protobuf field: string password = 1;
	 */
	password: string;
	/**
	 * @generated from protobuf field: string first_name = 2;
	 */
	firstName: string;
	/**
	 * @generated from protobuf field: string last_name = 3;
	 */
	lastName: string;
	/**
	 * @generated from protobuf field: string email = 4;
	 */
	email: string;
}
/**
 * @generated from protobuf message user.v1alpha.RegisterResponse
 */
export interface RegisterResponse {
	/**
	 * @generated from protobuf field: user.v1alpha.User user = 1;
	 */
	user?: User;
}
/**
 * @generated from protobuf message user.v1alpha.UpdateRequest
 */
export interface UpdateRequest {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string;
	/**
	 * @generated from protobuf field: string first_name = 2;
	 */
	firstName: string;
	/**
	 * @generated from protobuf field: string last_name = 3;
	 */
	lastName: string;
}
/**
 * @generated from protobuf message user.v1alpha.UpdateResponse
 */
export interface UpdateResponse {
	/**
	 * @generated from protobuf field: user.v1alpha.User user = 1;
	 */
	user?: User;
}
/**
 * @generated from protobuf message user.v1alpha.DeleteRequest
 */
export interface DeleteRequest {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string;
}
/**
 * @generated from protobuf message user.v1alpha.DeleteResponse
 */
export interface DeleteResponse {
	/**
	 * @generated from protobuf field: user.v1alpha.User user = 1;
	 */
	user?: User;
}
/**
 * @generated from protobuf message user.v1alpha.UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string;
	/**
	 * @generated from protobuf field: string password = 2;
	 */
	password: string;
}
/**
 * @generated from protobuf message user.v1alpha.UpdatePasswordResponse
 */
export interface UpdatePasswordResponse {
	/**
	 * @generated from protobuf field: user.v1alpha.User user = 1;
	 */
	user?: User;
}
/**
 * @generated from protobuf message user.v1alpha.FindRequest
 */
export interface FindRequest {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string;
	/**
	 * @generated from protobuf field: string first_name = 2;
	 */
	firstName: string;
	/**
	 * @generated from protobuf field: string last_name = 3;
	 */
	lastName: string;
	/**
	 * @generated from protobuf field: string email = 4;
	 */
	email: string;
}
/**
 * @generated from protobuf message user.v1alpha.FindResponse
 */
export interface FindResponse {
	/**
	 * @generated from protobuf field: repeated user.v1alpha.User user = 1;
	 */
	user: User[];
}
/**
 * @generated from protobuf message user.v1alpha.CheckPasswordRequest
 */
export interface CheckPasswordRequest {
	/**
	 * @generated from protobuf field: string email = 1;
	 */
	email: string;
	/**
	 * @generated from protobuf field: string password = 2;
	 */
	password: string;
}
/**
 * @generated from protobuf message user.v1alpha.CheckPasswordResponse
 */
export interface CheckPasswordResponse {
	/**
	 * @generated from protobuf field: user.v1alpha.CheckPasswordResponse.STATUS status = 1;
	 */
	status: CheckPasswordResponse_STATUS;
	/**
	 * @generated from protobuf field: user.v1alpha.User user = 2;
	 */
	user?: User;
}
/**
 * @generated from protobuf enum user.v1alpha.CheckPasswordResponse.STATUS
 */
export enum CheckPasswordResponse_STATUS {
	/**
	 * @generated from protobuf enum value: OK = 0;
	 */
	OK = 0,
	/**
	 * @generated from protobuf enum value: WRONG_PASSWORD = 1;
	 */
	WRONG_PASSWORD = 1,
	/**
	 * @generated from protobuf enum value: NOT_FOUND = 2;
	 */
	NOT_FOUND = 2,
	/**
	 * @generated from protobuf enum value: INTERNAL = 3;
	 */
	INTERNAL = 3
}
/**
 * @generated from protobuf message user.v1alpha.MakeAdminRequest
 */
export interface MakeAdminRequest {
	/**
	 * @generated from protobuf field: string id = 1;
	 */
	id: string;
	/**
	 * @generated from protobuf field: string email = 2;
	 */
	email: string;
}
/**
 * @generated from protobuf message user.v1alpha.MakeAdminResponse
 */
export interface MakeAdminResponse {
	/**
	 * @generated from protobuf field: user.v1alpha.User user = 1;
	 */
	user?: User;
}
/**
 * @generated from protobuf enum user.v1alpha.UserRole
 */
export enum UserRole {
	/**
	 * @generated from protobuf enum value: USER_ROLE_BASIC = 0;
	 */
	BASIC = 0,
	/**
	 * @generated from protobuf enum value: USER_ROLE_ADMIN = 1;
	 */
	ADMIN = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
	constructor() {
		super('user.v1alpha.User', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'first_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'last_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'email', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 5, name: 'created_at', kind: 'message', T: () => Timestamp },
			{ no: 6, name: 'updated_at', kind: 'message', T: () => Timestamp },
			{
				no: 7,
				name: 'role',
				kind: 'enum',
				T: () => ['user.v1alpha.UserRole', UserRole, 'USER_ROLE_']
			}
		]);
	}
	create(value?: PartialMessage<User>): User {
		const message = { id: '', firstName: '', lastName: '', email: '', role: 0 };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<User>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: User
	): User {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string();
					break;
				case /* string first_name */ 2:
					message.firstName = reader.string();
					break;
				case /* string last_name */ 3:
					message.lastName = reader.string();
					break;
				case /* string email */ 4:
					message.email = reader.string();
					break;
				case /* google.protobuf.Timestamp created_at */ 5:
					message.createdAt = Timestamp.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.createdAt
					);
					break;
				case /* google.protobuf.Timestamp updated_at */ 6:
					message.updatedAt = Timestamp.internalBinaryRead(
						reader,
						reader.uint32(),
						options,
						message.updatedAt
					);
					break;
				case /* user.v1alpha.UserRole role */ 7:
					message.role = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: User,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
		/* string first_name = 2; */
		if (message.firstName !== '') writer.tag(2, WireType.LengthDelimited).string(message.firstName);
		/* string last_name = 3; */
		if (message.lastName !== '') writer.tag(3, WireType.LengthDelimited).string(message.lastName);
		/* string email = 4; */
		if (message.email !== '') writer.tag(4, WireType.LengthDelimited).string(message.email);
		/* google.protobuf.Timestamp created_at = 5; */
		if (message.createdAt)
			Timestamp.internalBinaryWrite(
				message.createdAt,
				writer.tag(5, WireType.LengthDelimited).fork(),
				options
			).join();
		/* google.protobuf.Timestamp updated_at = 6; */
		if (message.updatedAt)
			Timestamp.internalBinaryWrite(
				message.updatedAt,
				writer.tag(6, WireType.LengthDelimited).fork(),
				options
			).join();
		/* user.v1alpha.UserRole role = 7; */
		if (message.role !== 0) writer.tag(7, WireType.Varint).int32(message.role);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRequest$Type extends MessageType<RegisterRequest> {
	constructor() {
		super('user.v1alpha.RegisterRequest', [
			{ no: 1, name: 'password', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'first_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'last_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'email', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<RegisterRequest>): RegisterRequest {
		const message = { password: '', firstName: '', lastName: '', email: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<RegisterRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: RegisterRequest
	): RegisterRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string password */ 1:
					message.password = reader.string();
					break;
				case /* string first_name */ 2:
					message.firstName = reader.string();
					break;
				case /* string last_name */ 3:
					message.lastName = reader.string();
					break;
				case /* string email */ 4:
					message.email = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: RegisterRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string password = 1; */
		if (message.password !== '') writer.tag(1, WireType.LengthDelimited).string(message.password);
		/* string first_name = 2; */
		if (message.firstName !== '') writer.tag(2, WireType.LengthDelimited).string(message.firstName);
		/* string last_name = 3; */
		if (message.lastName !== '') writer.tag(3, WireType.LengthDelimited).string(message.lastName);
		/* string email = 4; */
		if (message.email !== '') writer.tag(4, WireType.LengthDelimited).string(message.email);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.RegisterRequest
 */
export const RegisterRequest = new RegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterResponse$Type extends MessageType<RegisterResponse> {
	constructor() {
		super('user.v1alpha.RegisterResponse', [
			{ no: 1, name: 'user', kind: 'message', T: () => User }
		]);
	}
	create(value?: PartialMessage<RegisterResponse>): RegisterResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<RegisterResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: RegisterResponse
	): RegisterResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* user.v1alpha.User user */ 1:
					message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: RegisterResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* user.v1alpha.User user = 1; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.RegisterResponse
 */
export const RegisterResponse = new RegisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRequest$Type extends MessageType<UpdateRequest> {
	constructor() {
		super('user.v1alpha.UpdateRequest', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'first_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'last_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<UpdateRequest>): UpdateRequest {
		const message = { id: '', firstName: '', lastName: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<UpdateRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UpdateRequest
	): UpdateRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string();
					break;
				case /* string first_name */ 2:
					message.firstName = reader.string();
					break;
				case /* string last_name */ 3:
					message.lastName = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: UpdateRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
		/* string first_name = 2; */
		if (message.firstName !== '') writer.tag(2, WireType.LengthDelimited).string(message.firstName);
		/* string last_name = 3; */
		if (message.lastName !== '') writer.tag(3, WireType.LengthDelimited).string(message.lastName);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.UpdateRequest
 */
export const UpdateRequest = new UpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
	constructor() {
		super('user.v1alpha.UpdateResponse', [{ no: 1, name: 'user', kind: 'message', T: () => User }]);
	}
	create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<UpdateResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UpdateResponse
	): UpdateResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* user.v1alpha.User user */ 1:
					message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: UpdateResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* user.v1alpha.User user = 1; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRequest$Type extends MessageType<DeleteRequest> {
	constructor() {
		super('user.v1alpha.DeleteRequest', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<DeleteRequest>): DeleteRequest {
		const message = { id: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<DeleteRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: DeleteRequest
	): DeleteRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: DeleteRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.DeleteRequest
 */
export const DeleteRequest = new DeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteResponse$Type extends MessageType<DeleteResponse> {
	constructor() {
		super('user.v1alpha.DeleteResponse', [{ no: 1, name: 'user', kind: 'message', T: () => User }]);
	}
	create(value?: PartialMessage<DeleteResponse>): DeleteResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<DeleteResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: DeleteResponse
	): DeleteResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* user.v1alpha.User user */ 1:
					message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: DeleteResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* user.v1alpha.User user = 1; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.DeleteResponse
 */
export const DeleteResponse = new DeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePasswordRequest$Type extends MessageType<UpdatePasswordRequest> {
	constructor() {
		super('user.v1alpha.UpdatePasswordRequest', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'password', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<UpdatePasswordRequest>): UpdatePasswordRequest {
		const message = { id: '', password: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<UpdatePasswordRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UpdatePasswordRequest
	): UpdatePasswordRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string();
					break;
				case /* string password */ 2:
					message.password = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: UpdatePasswordRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
		/* string password = 2; */
		if (message.password !== '') writer.tag(2, WireType.LengthDelimited).string(message.password);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.UpdatePasswordRequest
 */
export const UpdatePasswordRequest = new UpdatePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePasswordResponse$Type extends MessageType<UpdatePasswordResponse> {
	constructor() {
		super('user.v1alpha.UpdatePasswordResponse', [
			{ no: 1, name: 'user', kind: 'message', T: () => User }
		]);
	}
	create(value?: PartialMessage<UpdatePasswordResponse>): UpdatePasswordResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<UpdatePasswordResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: UpdatePasswordResponse
	): UpdatePasswordResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* user.v1alpha.User user */ 1:
					message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: UpdatePasswordResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* user.v1alpha.User user = 1; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.UpdatePasswordResponse
 */
export const UpdatePasswordResponse = new UpdatePasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindRequest$Type extends MessageType<FindRequest> {
	constructor() {
		super('user.v1alpha.FindRequest', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'first_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'last_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'email', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<FindRequest>): FindRequest {
		const message = { id: '', firstName: '', lastName: '', email: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<FindRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: FindRequest
	): FindRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string();
					break;
				case /* string first_name */ 2:
					message.firstName = reader.string();
					break;
				case /* string last_name */ 3:
					message.lastName = reader.string();
					break;
				case /* string email */ 4:
					message.email = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: FindRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
		/* string first_name = 2; */
		if (message.firstName !== '') writer.tag(2, WireType.LengthDelimited).string(message.firstName);
		/* string last_name = 3; */
		if (message.lastName !== '') writer.tag(3, WireType.LengthDelimited).string(message.lastName);
		/* string email = 4; */
		if (message.email !== '') writer.tag(4, WireType.LengthDelimited).string(message.email);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.FindRequest
 */
export const FindRequest = new FindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindResponse$Type extends MessageType<FindResponse> {
	constructor() {
		super('user.v1alpha.FindResponse', [
			{ no: 1, name: 'user', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => User }
		]);
	}
	create(value?: PartialMessage<FindResponse>): FindResponse {
		const message = { user: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<FindResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: FindResponse
	): FindResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated user.v1alpha.User user */ 1:
					message.user.push(User.internalBinaryRead(reader, reader.uint32(), options));
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: FindResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* repeated user.v1alpha.User user = 1; */
		for (let i = 0; i < message.user.length; i++)
			User.internalBinaryWrite(
				message.user[i],
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.FindResponse
 */
export const FindResponse = new FindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPasswordRequest$Type extends MessageType<CheckPasswordRequest> {
	constructor() {
		super('user.v1alpha.CheckPasswordRequest', [
			{ no: 1, name: 'email', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'password', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<CheckPasswordRequest>): CheckPasswordRequest {
		const message = { email: '', password: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<CheckPasswordRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CheckPasswordRequest
	): CheckPasswordRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string email */ 1:
					message.email = reader.string();
					break;
				case /* string password */ 2:
					message.password = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CheckPasswordRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string email = 1; */
		if (message.email !== '') writer.tag(1, WireType.LengthDelimited).string(message.email);
		/* string password = 2; */
		if (message.password !== '') writer.tag(2, WireType.LengthDelimited).string(message.password);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.CheckPasswordRequest
 */
export const CheckPasswordRequest = new CheckPasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPasswordResponse$Type extends MessageType<CheckPasswordResponse> {
	constructor() {
		super('user.v1alpha.CheckPasswordResponse', [
			{
				no: 1,
				name: 'status',
				kind: 'enum',
				T: () => ['user.v1alpha.CheckPasswordResponse.STATUS', CheckPasswordResponse_STATUS]
			},
			{ no: 2, name: 'user', kind: 'message', T: () => User }
		]);
	}
	create(value?: PartialMessage<CheckPasswordResponse>): CheckPasswordResponse {
		const message = { status: 0 };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<CheckPasswordResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CheckPasswordResponse
	): CheckPasswordResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* user.v1alpha.CheckPasswordResponse.STATUS status */ 1:
					message.status = reader.int32();
					break;
				case /* user.v1alpha.User user */ 2:
					message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CheckPasswordResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* user.v1alpha.CheckPasswordResponse.STATUS status = 1; */
		if (message.status !== 0) writer.tag(1, WireType.Varint).int32(message.status);
		/* user.v1alpha.User user = 2; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(2, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.CheckPasswordResponse
 */
export const CheckPasswordResponse = new CheckPasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeAdminRequest$Type extends MessageType<MakeAdminRequest> {
	constructor() {
		super('user.v1alpha.MakeAdminRequest', [
			{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'email', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<MakeAdminRequest>): MakeAdminRequest {
		const message = { id: '', email: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<MakeAdminRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: MakeAdminRequest
	): MakeAdminRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string id */ 1:
					message.id = reader.string();
					break;
				case /* string email */ 2:
					message.email = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: MakeAdminRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string id = 1; */
		if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
		/* string email = 2; */
		if (message.email !== '') writer.tag(2, WireType.LengthDelimited).string(message.email);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.MakeAdminRequest
 */
export const MakeAdminRequest = new MakeAdminRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeAdminResponse$Type extends MessageType<MakeAdminResponse> {
	constructor() {
		super('user.v1alpha.MakeAdminResponse', [
			{ no: 1, name: 'user', kind: 'message', T: () => User }
		]);
	}
	create(value?: PartialMessage<MakeAdminResponse>): MakeAdminResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined) reflectionMergePartial<MakeAdminResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: MakeAdminResponse
	): MakeAdminResponse {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* user.v1alpha.User user */ 1:
					message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: MakeAdminResponse,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* user.v1alpha.User user = 1; */
		if (message.user)
			User.internalBinaryWrite(
				message.user,
				writer.tag(1, WireType.LengthDelimited).fork(),
				options
			).join();
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message user.v1alpha.MakeAdminResponse
 */
export const MakeAdminResponse = new MakeAdminResponse$Type();
